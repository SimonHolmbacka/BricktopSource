/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*                                                      */
/* File:  PowerFuzzy.c                                  */
/*                                                      */
/* Author: Automatically generated by Xfuzzy            */
/*                                                      */
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

#include <stdio.h>
#include <math.h>
#include "PowerFuzzy.h"

/*======================================================*/
/*  MembershipFunction MF_xfl_triangle                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_triangle_equal(double x, double min, double max, double step, double a, double b, double c) {
    return (a<x && x<=b? (x-a)/(b-a) : (b<x && x<c? (c-x)/(c-b) : 0)); 

}

/*======================================================*/
/*  MembershipFunction MF_xfl_trapezoid                 */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_trapezoid_equal(double x, double min, double max, double step, double a, double b, double c, double d) {
    return (x<a || x>d? 0: (x<b? (x-a)/(b-a) : (x<c?1 : (d-x)/(d-c)))); 

}

/*======================================================*/
/*  MembershipFunction MF_xfl_sigma                     */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_sigma_equal(double x, double min, double max, double step, double a, double b) {
    return 1/(1+ exp( (a-x)/b )); 

}

/*======================================================*/
/*  MembershipFunction MF_xfl_bell                      */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_bell_equal(double x, double min, double max, double step, double a, double b) {
    return exp( -(a-x)*(a-x)/(b*b) ); 

}

/*======================================================*/
/*  Operatorset OP_Ops                                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the operator AND                      */
/*------------------------------------------------------*/

static double OP_Ops_And(double a, double b) {
    return a*b; 

}

/*------------------------------------------------------*/
/* Description of the defuzzification method            */
/*------------------------------------------------------*/

static double OP_Ops_Defuz(FuzzyNumber2 mf) {
 double min = mf.min;
 double max = mf.max;
     double num=0, denom=0;
     int i;
     for(i=0; i<mf.length; i++) {
      num += mf.degree[i]*mf.conc[i].basis()*mf.conc[i].center();
      denom += mf.degree[i]*mf.conc[i].basis();
     }
     if(denom==0) return (min+max)/2;
     return num/denom;

}


/*======================================================*/
/*  Type TP_InputError                                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label TooMuchMan                  */
/*------------------------------------------------------*/

static double TP_InputError_TooMuchMan_equal(double x){
   return MF_xfl_triangle_equal(x,-1.0,1.0,0.00784313725490196,-1.5,-1.0,-0.5);
}

/*------------------------------------------------------*/
/* Description of the label LittleTooMuch               */
/*------------------------------------------------------*/

static double TP_InputError_LittleTooMuch_equal(double x){
   return MF_xfl_triangle_equal(x,-1.0,1.0,0.00784313725490196,-0.9,-0.35,-0.05);
}

/*------------------------------------------------------*/
/* Description of the label Zero                        */
/*------------------------------------------------------*/

static double TP_InputError_Zero_equal(double x){
   return MF_xfl_triangle_equal(x,-1.0,1.0,0.00784313725490196,-0.4,0.0,0.4);
}

/*------------------------------------------------------*/
/* Description of the label LittleTooLittle             */
/*------------------------------------------------------*/

static double TP_InputError_LittleTooLittle_equal(double x){
   return MF_xfl_triangle_equal(x,-1.0,1.0,0.00784313725490196,0.05,0.35,0.9);
}

/*------------------------------------------------------*/
/* Description of the label Starving                    */
/*------------------------------------------------------*/

static double TP_InputError_Starving_equal(double x){
   return MF_xfl_triangle_equal(x,-1.0,1.0,0.00784313725490196,0.5,1.0,1.4);
}

/*======================================================*/
/*  Type TP_InputErrorSum                               */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label TooMuchMan                  */
/*------------------------------------------------------*/

static double TP_InputErrorSum_TooMuchMan_equal(double x){
   return MF_xfl_trapezoid_equal(x,-14.0,14.0,0.10980392156862745,-18.666666666666668,-14.0,-10.1,-2.55);
}

/*------------------------------------------------------*/
/* Description of the label LittleTooMuch               */
/*------------------------------------------------------*/

static double TP_InputErrorSum_LittleTooMuch_equal(double x){
   return MF_xfl_triangle_equal(x,-14.0,14.0,0.10980392156862745,-3.3,-1.74,-0.7);
}

/*------------------------------------------------------*/
/* Description of the label Zero                        */
/*------------------------------------------------------*/

static double TP_InputErrorSum_Zero_equal(double x){
   return MF_xfl_triangle_equal(x,-14.0,14.0,0.10980392156862745,-0.778,0.0,0.63);
}

/*------------------------------------------------------*/
/* Description of the label LittleTooLittle             */
/*------------------------------------------------------*/

static double TP_InputErrorSum_LittleTooLittle_equal(double x){
   return MF_xfl_triangle_equal(x,-14.0,14.0,0.10980392156862745,0.415,1.52,2.85);
}

/*------------------------------------------------------*/
/* Description of the label MuchTooLittle               */
/*------------------------------------------------------*/

static double TP_InputErrorSum_MuchTooLittle_equal(double x){
   return MF_xfl_trapezoid_equal(x,-14.0,14.0,0.10980392156862745,2.33,8.93,14.0,24.0);
}

/*======================================================*/
/*  Type TP_Output                                      */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label MuchDown                    */
/*------------------------------------------------------*/

static double TP_Output_MuchDown_equal(double x){
   return MF_xfl_sigma_equal(x,-1.5,1.5,0.011764705882352941,-0.75,-0.2);
}

/*------------------------------------------------------*/
/* Description of the label LittleDown                  */
/*------------------------------------------------------*/

static double TP_Output_LittleDown_equal(double x){
   return MF_xfl_bell_equal(x,-1.5,1.5,0.011764705882352941,-0.35,0.1);
}

/*------------------------------------------------------*/
/* Description of the label NoChange                    */
/*------------------------------------------------------*/

static double TP_Output_NoChange_equal(double x){
   return MF_xfl_bell_equal(x,-1.5,1.5,0.011764705882352941,0.0,0.15);
}

/*------------------------------------------------------*/
/* Description of the label LittleUp                    */
/*------------------------------------------------------*/

static double TP_Output_LittleUp_equal(double x){
   return MF_xfl_bell_equal(x,-1.5,1.5,0.011764705882352941,0.35,0.1);
}

/*------------------------------------------------------*/
/* Description of the label MuchUp                      */
/*------------------------------------------------------*/

static double TP_Output_MuchUp_equal(double x){
   return MF_xfl_sigma_equal(x,-1.5,1.5,0.011764705882352941,0.75,0.2);
}

/*======================================================*/
/*  Type TP_Output2                                     */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label MuchDown                    */
/*------------------------------------------------------*/

static double TP_Output2_MuchDown_equal(double x){
   return MF_xfl_trapezoid_equal(x,-1.5,1.5,0.011764705882352941,-1.6,-1.5,-1.2,-0.7);
}

static double TP_Output2_MuchDown_center(){
   return -1.35;
}

static double TP_Output2_MuchDown_basis(){
   return 0.9000000000000001;
}

/*------------------------------------------------------*/
/* Description of the label LittleDown                  */
/*------------------------------------------------------*/

static double TP_Output2_LittleDown_equal(double x){
   return MF_xfl_triangle_equal(x,-1.5,1.5,0.011764705882352941,-1.3,-0.5,-0.05);
}

static double TP_Output2_LittleDown_center(){
   return -0.5;
}

static double TP_Output2_LittleDown_basis(){
   return 1.25;
}

/*------------------------------------------------------*/
/* Description of the label NoChange                    */
/*------------------------------------------------------*/

static double TP_Output2_NoChange_equal(double x){
   return MF_xfl_triangle_equal(x,-1.5,1.5,0.011764705882352941,-0.4,0.0,0.4);
}

static double TP_Output2_NoChange_center(){
   return 0.0;
}

static double TP_Output2_NoChange_basis(){
   return 0.8;
}

/*------------------------------------------------------*/
/* Description of the label LittleUp                    */
/*------------------------------------------------------*/

static double TP_Output2_LittleUp_equal(double x){
   return MF_xfl_triangle_equal(x,-1.5,1.5,0.011764705882352941,0.05,0.5,1.3);
}

static double TP_Output2_LittleUp_center(){
   return 0.5;
}

static double TP_Output2_LittleUp_basis(){
   return 1.25;
}

/*------------------------------------------------------*/
/* Description of the label MuchUp                      */
/*------------------------------------------------------*/

static double TP_Output2_MuchUp_equal(double x){
   return MF_xfl_trapezoid_equal(x,-1.5,1.5,0.011764705882352941,0.7,1.2,1.5,2.0);
}

static double TP_Output2_MuchUp_center(){
   return 1.35;
}

static double TP_Output2_MuchUp_basis(){
   return 1.3;
}

/*======================================================*/
/*  Rulebase RL_Prules                                  */
/*======================================================*/

static void RL_Prules(double E, double ES, double *O2) {
 double _rl;

 double _O2_degree[13];
 Consequent _O2_conc[13];
 FuzzyNumber2 _O2;
 _O2.min = -1.5;
 _O2.max = 1.5;
 _O2.step = 0.011764705882352941;
 _O2.length = 13;
 _O2.degree = _O2_degree;
 _O2.conc = _O2_conc;
 int _O2_i = 0;

 double _E_eq[5];
 _E_eq[0] = TP_InputError_TooMuchMan_equal(E);
 _E_eq[1] = TP_InputError_LittleTooMuch_equal(E);
 _E_eq[2] = TP_InputError_Zero_equal(E);
 _E_eq[3] = TP_InputError_LittleTooLittle_equal(E);
 _E_eq[4] = TP_InputError_Starving_equal(E);

 double _ES_eq[5];
 _ES_eq[0] = TP_InputErrorSum_TooMuchMan_equal(ES);
 _ES_eq[1] = TP_InputErrorSum_LittleTooMuch_equal(ES);
 _ES_eq[2] = TP_InputErrorSum_Zero_equal(ES);
 _ES_eq[3] = TP_InputErrorSum_LittleTooLittle_equal(ES);
 _ES_eq[4] = TP_InputErrorSum_MuchTooLittle_equal(ES);

 _rl = _E_eq[0];
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_MuchDown_equal;
 _O2_conc[_O2_i].center = TP_Output2_MuchDown_center;
 _O2_conc[_O2_i].basis = TP_Output2_MuchDown_basis;
 _O2_i++;

 _rl = _E_eq[1];
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_LittleDown_equal;
 _O2_conc[_O2_i].center = TP_Output2_LittleDown_center;
 _O2_conc[_O2_i].basis = TP_Output2_LittleDown_basis;
 _O2_i++;

 _rl = _E_eq[2];
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_NoChange_equal;
 _O2_conc[_O2_i].center = TP_Output2_NoChange_center;
 _O2_conc[_O2_i].basis = TP_Output2_NoChange_basis;
 _O2_i++;

 _rl = _E_eq[3];
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_LittleUp_equal;
 _O2_conc[_O2_i].center = TP_Output2_LittleUp_center;
 _O2_conc[_O2_i].basis = TP_Output2_LittleUp_basis;
 _O2_i++;

 _rl = _E_eq[4];
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_MuchUp_equal;
 _O2_conc[_O2_i].center = TP_Output2_MuchUp_center;
 _O2_conc[_O2_i].basis = TP_Output2_MuchUp_basis;
 _O2_i++;

 _rl = OP_Ops_And(_E_eq[1],_ES_eq[3]);
 _rl = 0.18 * _rl;
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_NoChange_equal;
 _O2_conc[_O2_i].center = TP_Output2_NoChange_center;
 _O2_conc[_O2_i].basis = TP_Output2_NoChange_basis;
 _O2_i++;

 _rl = OP_Ops_And(_E_eq[3],_ES_eq[1]);
 _rl = 0.18 * _rl;
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_NoChange_equal;
 _O2_conc[_O2_i].center = TP_Output2_NoChange_center;
 _O2_conc[_O2_i].basis = TP_Output2_NoChange_basis;
 _O2_i++;

 _rl = OP_Ops_And(_E_eq[2],_ES_eq[4]);
 _rl = 0.18 * _rl;
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_LittleUp_equal;
 _O2_conc[_O2_i].center = TP_Output2_LittleUp_center;
 _O2_conc[_O2_i].basis = TP_Output2_LittleUp_basis;
 _O2_i++;

 _rl = OP_Ops_And(_E_eq[2],_ES_eq[0]);
 _rl = 0.18 * _rl;
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_LittleDown_equal;
 _O2_conc[_O2_i].center = TP_Output2_LittleDown_center;
 _O2_conc[_O2_i].basis = TP_Output2_LittleDown_basis;
 _O2_i++;

 _rl = OP_Ops_And(_E_eq[0],_ES_eq[4]);
 _rl = 0.18 * _rl;
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_NoChange_equal;
 _O2_conc[_O2_i].center = TP_Output2_NoChange_center;
 _O2_conc[_O2_i].basis = TP_Output2_NoChange_basis;
 _O2_i++;

 _rl = OP_Ops_And(_E_eq[4],_ES_eq[0]);
 _rl = 0.18 * _rl;
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_NoChange_equal;
 _O2_conc[_O2_i].center = TP_Output2_NoChange_center;
 _O2_conc[_O2_i].basis = TP_Output2_NoChange_basis;
 _O2_i++;

 _rl = OP_Ops_And(_E_eq[1],_ES_eq[0]);
 _rl = 0.18 * _rl;
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_MuchDown_equal;
 _O2_conc[_O2_i].center = TP_Output2_MuchDown_center;
 _O2_conc[_O2_i].basis = TP_Output2_MuchDown_basis;
 _O2_i++;

 _rl = OP_Ops_And(_E_eq[3],_ES_eq[4]);
 _rl = 0.18 * _rl;
 _O2_degree[_O2_i] = _rl;
 _O2_conc[_O2_i].equal = TP_Output2_MuchUp_equal;
 _O2_conc[_O2_i].center = TP_Output2_MuchUp_center;
 _O2_conc[_O2_i].basis = TP_Output2_MuchUp_basis;
 _O2_i++;

 *O2 = OP_Ops_Defuz(_O2);
}


/*======================================================*/
/*                   Inference Engine                   */
/*======================================================*/

void PowerFuzzyInferenceEngine(double Error, double ErrorSum, double *_d_Out) {
 double Out;
 RL_Prules(Error, ErrorSum, &Out);
 *_d_Out = Out;
#if 0
 printf("In %f In sum %f Out %f\n",Error, ErrorSum, Out);
#endif
}

